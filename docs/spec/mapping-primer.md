# SKL Mapping Primer

This document outlines in detail how SKL Verbs and Mappings work, and provides some examples for complex mapping scenarios.

## Namespaces

In this document, examples assume the following namespace prefix bindings unless otherwise stated:

| Prefix | IRI |
| ---- | ---- |
| skl: | https://standardknowledge.com/ontologies/core/ |
| rdf: | http://www.w3.org/1999/02/22-rdf-syntax-ns# |
| rdfs: | http://www.w3.org/2000/01/rdf-schema# |
| shacl: | http://www.w3.org/ns/shacl# |
| fnml: | http://semweb.mmlab.be/ns/fnml# |
| dcelements: | http://purl.org/dc/elements/1.1/ |
| dcterms: | http://purl.org/dc/terms/ |
| rr: | http://www.w3.org/ns/r2rml# |
| rml: | http://semweb.mmlab.be/ns/rml# |
| owl: | http://www.w3.org/2002/07/owl# |
| xsd: | http://www.w3.org/2001/XMLSchema# |
| schema: | https://schema.org/ |

## Verb Execution Flow

Coming soon...

## Complex Mapping Scenarios

### Nested Arrays

Lets say that an API operation responds to us with a list of event objects that each have some nested data about their venue. We want to create an `returnValueMapping` which transforms the nested data into an object that holds a list of events and a list of locations.

```js
{
  data: {
    events: [
      {
        id: "event-1",
        title: "Governor's Ball",
        venue: {
          id: "venue-1",
          title: "City Hall"
        }
      },
      {
        id: "event-2",
        title: "Texas Family Rodeo",
        venue: {
          id: "venue-2",
          title: "County Fair"
        }
      }
    ]
  }
}
```

We want to map it into a JSON-LD like this

```js
{
  "@type": "skl:Collection",
  "example:events": [
    {
      "@id": "https://example.com/events/event-1",
      "@type": "https://schema.org/Event",
      "schema:name": "Governor's Ball",
      "schema:location": "https://example.com/locations/location-1"
    },
    {
      "@id": "https://example.com/events/event-2",
      "@type": "https://schema.org/Event",
      "schema:name": "Texas Family Rodeo",
      "schema:location": "https://example.com/locations/location-2"
    }
  ],
  "example:locations": [
    {
      "@id": "https://example.com/locations/location-1",
      "@type": "https://schema.org/Place",
      "schema:name": "City Hall",
    },
    {
      "@id": "https://example.com/locations/location-2",
      "@type": "https://schema.org/Place",
      "schema:name": "County Fair",
    }
  ]
}
```

We can use a `returnValueMapping` like the one below. Note the comments sprinkled within the JSON.

```js
{ // This TriplesMap will create our top level object, the `skl:Collection`
  "@type": "rr:TriplesMap",
  "rml:logicalSource": {
    "@type": "rml:LogicalSource",
    "rml:iterator": "$.data", 
    "rml:referenceFormulation": "http://semweb.mmlab.be/ns/ql#JSONPath",
    "rml:source": "input.json"
  },
  "rr:predicateObjectMap": [
    {
      "@type": "rr:PredicateObjectMap",
      "rr:predicate": "example:events",
      "rr:objectMap": {
        "@type": "rr:ObjectMap",
        // This rr:parentTriplesMap creates a "referencing object map" that allows using 
        // the subjects of another triples map as the objects of triples generated by a predicate-object map.
        // In this case, it is allowing us to set the schema:Event objects generated below be the 
        // objects of triples with the example:events predicate.
        "rr:parentTriplesMap": {
          "@type": "rr:TriplesMap",
          "rml:logicalSource": {
            "@type": "rml:LogicalSource",
            // Iterate over the events using JSONPath
            "rml:iterator": "$.data.events[*]",
            "rml:referenceFormulation": "http://semweb.mmlab.be/ns/ql#JSONPath",
            "rml:source": "input.json"
          },
          "rr:predicateObjectMap": [
            {
              "@type": "rr:PredicateObjectMap",
              "rr:objectMap": {
                "@type": "rr:ObjectMap",
                // Reference the `title` field of each event. RML references used in 
                // rr:predicateObjectMaps are JSONPaths relative to the iterator of the logical source `$.data.events[*]`
                "rml:reference": "title",
                "rr:datatype": "http://www.w3.org/2001/XMLSchema#string"
              },
              "rr:predicate": "schema:name"
            },
            {
              "@type": "rr:PredicateObjectMap",
              "rr:objectMap": {
                "@type": "rr:ObjectMap",
                // Use a template to set the schema:locations field on events to the URI of the locations we create below
                "rr:template": "https://example.com/locations/{venue.id}",
                // In the triple we're creating, we want to make sure that the object is an IRI, not a literal
                "rr:termType": "rr:IRI"
              },
              "rr:predicate": "schema:location"
            },
          ],
          "rr:subjectMap": {
            "@type": "rr:SubjectMap",
            // Use an rr:template to generate the URI of each event. The templated strings 
            // here are a JSONPath relative to the iterator of the logical source `$.data.events[*]`
            "rr:template": "https://example.com/events/{id}",
            "rr:class": "schema:Event"
          }
        }
      }
    },
    {
      "@type": "rr:PredicateObjectMap",
      "rr:predicate": "example:locations",
      "rr:objectMap": {
        "@type": "rr:ObjectMap",
        // This sets the resulting schema:Place objects generated below be the 
        // objects of triples with the example:locations predicate.
        "rr:parentTriplesMap": {
          "@type": "rr:TriplesMap",
          "rml:logicalSource": {
            "@type": "rml:LogicalSource",
            // Iterate over the events again but access the `venue` property of each
            "rml:iterator": "$.data.events[*].venue",
            "rml:referenceFormulation": "http://semweb.mmlab.be/ns/ql#JSONPath",
            "rml:source": "input.json"
          },
          "rr:predicateObjectMap": [
            {
              "@type": "rr:PredicateObjectMap",
              "rr:objectMap": {
                "@type": "rr:ObjectMap",
                // Reference the `title` field of each location. This reference is 
                // relative to the iterator of the logical source `$.data.events[*]`
                "rml:reference": "title",
                "rr:datatype": "http://www.w3.org/2001/XMLSchema#string"
              },
              "rr:predicate": "schema:name"
            },
          ],
          "rr:subjectMap": {
            "@type": "rr:SubjectMap",
            // Use an rr:template to generate the URI of each location. The templated strings 
            // here are a JSONPath relative to the iterator of the logical source `$.data.events[*]`
            "rr:template": "https://example.com/locations/{id}",
            "rr:class": "schema:Place"
          }
        }
      }
    }
  ],
  "rr:subjectMap": {
    "@type": "rr:SubjectMap",
    "rr:termType": "rr:BlankNode",
    "rr:class": "skl:Collection"
  }
}
```

If we used this `returnValueMapping` by itself, we might get some JSON we don't like. We use a [JSON-LD Framing](https://www.w3.org/TR/json-ld11-framing/) to make sure the JSON is in the format we want. Below is the `skl:returnValueFrame` we'd use with this mapping.

```js
{
  "@context": {
    // Tells JSON-LD that these fields are supposed to be sets, or unordered lists, even if there's just one item.
    "https://example.com/events": {
      "@container": "@set"
    },
    "https://example.com/locations": {
      "@container": "@set"
    }
  },
  // We specify the type of the node we want to frame around. If this was not used, 
  // it would return a list of every node in the RDF graph we just constructed
  "@type": "https://standardknowledge.com/ontologies/core/Collection",
  "https://example.com/events": {
    "https://schema.org/location": {
      // This tells JSON-LD not to nest the locations inside the events. Since
      // the events have a predicate that references the locations by URI, the 
      // default behavior is to nest the data.
      "@embed": "@never"
    },
  },
}
```